## Итоговый план добавления Telegram-бота для напоминаний о работе в проект imanagestuff

### 1. Анализ и подготовка

- Проверить наличие поля `telegram_id` в таблице `member`. При отсутствии добавить через Liquibase (тип `BIGINT`, уникальное).
- Использовать существующую таблицу `time_entry` для хранения записей.
- Создать таблицу `pending_link` для хранения кодов привязки:
  - `id` (PK), `member_id` (FK), `code` (уникальный), `created_at`, `expires_at`, `used`
- Создать таблицу `polling_state` для хранения последнего обработанного `update_id`:
  - `id` (PK), `last_update_id` (INT)
- Определить требования к боту:
  - Принимает сообщения в формате `длительность описание` (например, `2:00 разработка API`).
  - Сохраняет `TimeEntry` в БД для `defaultProject` участника, используя переданную длительность.
  - Поддерживает команды: `/start`, `/today`, `/help`.
  - Ежедневно в настроенное время отправляет напоминание, если за день нет ни одной записи.
  - Привязка Telegram ID через ссылку с уникальным кодом.
- Проверить зависимости в `build.gradle`:
  - `io.quarkus:quarkus-rest-client` (уже есть)
  - `io.quarkus:quarkus-scheduler` (уже есть)
  - `io.quarkus:quarkus-hibernate-orm-panache` (уже есть)

### 2. Создание REST-клиента для Telegram API

- Интерфейс `TelegramBotClient` в пакете `org.manage.client` с методами:
  - `sendMessage` (POST `/bot{token}/sendMessage`)
  - `getUpdates` (GET `/bot{token}/getUpdates?offset={offset}&timeout={timeout}`)
- DTO в `org.manage.client.dto`:
  - `SendMessageRequest`, `Update`, `Message`, `User`, `Chat`.
- Конфигурация в `application.properties`:
  - `telegram.bot.token=...`
  - `telegram.polling.interval=5s`

### 3. Модели данных (Panache)

- **Member.java**: Добавить `public Long telegramId;`.
- **PendingLink.java**:

```java
@Entity
@Table(name = "pending_link")
public class PendingLink extends PanacheEntityBase {
  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
  @SequenceGenerator(name = "sequenceGenerator")
  public Long id;

  @ManyToOne
  public Member member;

  @Column(unique = true)
  public String code;

  public Instant createdAt;
  public Instant expiresAt;
  public boolean used;
}

```

- **PollingState.java**:

```java
@Entity
@Table(name = "polling_state")
public class PollingState extends PanacheEntityBase {
  @Id
  public Long id; // Always 1

  public int lastUpdateId;
}

```

### 4. Сервисы

- **TelegramLinkService**: Генерация кодов и ссылок для привязки.
- **TelegramMessageHandler**: Логика обработки команд и парсинга сообщений.
- **TelegramPollingService**: Опрос Telegram API по расписанию с использованием интервала из конфигурации: `@Scheduled(every = "{telegram.polling.interval}")`.
- **TimeEntryService**: Использование существующего сервиса для сохранения записей.

### 5. Парсер сообщений

- Регулярное выражение: `^(\\d+:\\d{2})\\s+(.+)$`
- Преобразование `H:mm` в объект `java.time.Duration`.
- Валидация: длительность должна быть больше 0.

### 6. Механизм привязки

- В React-фронтенде добавить кнопку "Привязать Telegram", вызывающую API для генерации кода.
- Бот обрабатывает `/start CODE`, находит `PendingLink` и обновляет `Member.telegramId`.

### 7. Ежедневные напоминания

- `@Scheduled(cron = "{reminder.cron}")` в `ReminderService`.
- Проверка наличия `TimeEntry` для всех `Member` с привязанным Telegram.

### 8. Конфигурация (application.properties)

```properties
telegram.bot.token=${TELEGRAM_BOT_TOKEN}
telegram.polling.interval=5s
reminder.cron=0 0 19 * * MON-FRI
reminder.message=Вы ещё не отметили рабочее время сегодня. Отправьте сообщение в формате: `длительность описание` Например: `2:00 разработка API`
```

- **PollingState.java**:

```java
@Entity
@Table(name = "polling_state")
public class PollingState extends PanacheEntityBase {
  @Id
  public Long id; // Always 1

  public int lastUpdateId;
}

```

### 4. Сервисы

- **TelegramLinkService**: Генерация кодов и ссылок для привязки.
- **TelegramMessageHandler**: Логика обработки команд и парсинга сообщений.
- **TelegramPollingService**: Опрос Telegram API по расписанию с использованием интервала из конфигурации: `@Scheduled(every = "{telegram.polling.interval}")`.
- **TimeEntryService**: Использование существующего сервиса для сохранения записей.

### 5. Парсер сообщений

- Регулярное выражение: `^(\\d{1,2}:\\d{2})-(\\d{1,2}:\\d{2})\\s+(.+)$`
- Расчет `Duration` между временем начала и конца.
- Валидация: `start` < `end`.

### 6. Механизм привязки

- В React-фронтенде добавить кнопку "Привязать Telegram", вызывающую API для генерации кода.
- Бот обрабатывает `/start CODE`, находит `PendingLink` и обновляет `Member.telegramId`.

### 7. Ежедневные напоминания

- `@Scheduled(cron = "{reminder.cron}")` в `ReminderService`.
- Проверка наличия `TimeEntry` для всех `Member` с привязанным Telegram.

### 8. Конфигурация (application.properties)

```properties
telegram.bot.token=${TELEGRAM_BOT_TOKEN}
telegram.polling.interval=5s
reminder.cron=0 0 19 * * MON-FRI
```

### 9. Тестирование

- Unit-тесты для парсера.
- Интеграционные тесты для REST-клиента (с использованием Mockito для Telegram API).
