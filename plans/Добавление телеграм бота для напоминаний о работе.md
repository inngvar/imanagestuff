## Итоговый план добавления Telegram-бота для напоминаний о работе в проект imanagestuff

### 1. Анализ и подготовка

- Проверить наличие поля `telegram_id` в таблице `member`. При отсутствии добавить через Liquibase (тип `BIGINT`, уникальное).
- Использовать существующую таблицу `time_entry` для хранения записей.
- Создать таблицу `pending_link` для хранения кодов привязки:
  - `id` (PK), `member_id` (FK), `code` (уникальный), `created_at`, `expires_at`, `used`
- Создать таблицу `polling_state` для хранения последнего обработанного `update_id`:
  - `id` (PK), `last_update_id` (INT)
- Определить требования к боту:
  - Принимает сообщения в формате `длительность описание` (например, `2:00 разработка API`).
  - Сохраняет `TimeEntry` в БД для `defaultProject` участника, используя переданную длительность.
  - Поддерживает команды: `/start`, `/today`, `/help`.
  - Ежедневно в настроенное время отправляет напоминание, если за день нет ни одной записи.
  - Привязка Telegram ID через ссылку с уникальным кодом.
- Проверить зависимости в `build.gradle`:
  - `io.quarkus:quarkus-rest-client` (уже есть)
  - `io.quarkus:quarkus-scheduler` (уже есть)
  - `io.quarkus:quarkus-hibernate-orm-panache` (уже есть)

### 2. Создание REST-клиента для Telegram API

- Интерфейс `TelegramBotClient` в пакете `org.manage.client` с методами:
  - `sendMessage` (POST `/bot{token}/sendMessage`)
  - `getUpdates` (GET `/bot{token}/getUpdates?offset={offset}&timeout={timeout}`)
- DTO в `org.manage.client.dto`:
  - `SendMessageRequest`, `Update`, `Message`, `User`, `Chat`.
- Конфигурация в `application.properties`:
  - `telegram.bot.token=...`
  - `telegram.polling.interval=5s`

### 3. Модели данных (Panache)

- **Member.java**: Добавить `public Long telegramId;`.
- **PendingLink.java**:

```java
@Entity
@Table(name = "pending_link")
public class PendingLink extends PanacheEntityBase {
  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "sequenceGenerator")
  @SequenceGenerator(name = "sequenceGenerator")
  public Long id;

  @ManyToOne
  public Member member;

  @Column(unique = true)
  public String code;

  public Instant createdAt;
  public Instant expiresAt;
  public boolean used;
}

```

- **PollingState.java**:

```java
@Entity
@Table(name = "polling_state")
public class PollingState extends PanacheEntityBase {
  @Id
  public Long id; // Always 1

  public int lastUpdateId;
}

```

### 4. Сервисы

- **TelegramLinkService**: Генерация кодов и ссылок для привязки. Включает метод очистки устаревших (`expiresAt < now`) или уже использованных записей, вызываемый по расписанию `@Scheduled`.
- **TelegramMessageHandler**: Логика обработки команд и парсинга сообщений.
- **TelegramPollingService**: Опрос Telegram API по расписанию: `@Scheduled(every = "{telegram.polling.interval}")`.
- **TimeEntryService**: Использование существующего сервиса для сохранения записей.

### 5. Парсер сообщений

Бот должен поддерживать форматы ввода времени, аналогичные фронтенду (см. `date-utils.ts`):

- **Поддерживаемые форматы времени:**
  - `Ч:ММ` (например, `2:30`, `1:00`, `0:45`).
  - Натуральный формат: `Xч Yм` или `Xh Ym` (например, `2ч 30м`, `1ч`, `20м`, `1h 15m`).
  - Поддержка кириллицы (`ч`, `м`) и латиницы (`h`, `m`).
- **Логика обработки:**
  1. **Нормализация**: Приведение к верхнему регистру, удаление пробелов.
  2. **Маппинг символов**: Замена кириллических `Ч` -> `H`, `М` -> `M` (аналог `formatDuration` на фронте).
  3. **Парсинг Duration**:
     - Если соответствует паттерну `^(\\d{1,2}):(\\d{2})$` -> преобразуем в часы и минуты.
     - Если содержит метки `H`/`M` -> извлекаем значения (например, через regex `(\\d+)H` и `(\\d+)M`).
  4. **Результат**: Создание объекта `java.time.Duration` для сохранения в `TimeEntry`.
- **Формат сообщения**: `^(\\S+)\\s+(.+)$` (Первое слово — время, остальное — описание).
- **Валидация**: Длительность должна быть больше 0. Если используется формат `Ч:ММ`, минуты должны быть меньше 60.

### 6. Механизм привязки (Deep Link)

#### 6.1. Инициация привязки (Web)

- В личном кабинете (веб-интерфейс) пользователь нажимает кнопку **«Подключить Telegram»**.
- Фронтенд отправляет POST-запрос на серверный эндпоинт: `POST /api/telegram/generate-link`.

#### 6.2. Обработка на сервере (Quarkus)

- **Проверка аутентификации**: получение текущего `Member` из контекста безопасности.
- **Генерация кода**: `TelegramLinkService.generateCode(member)`.
  - Используется криптостойкий генератор (UUID или случайная строка 32 символа).
  - Создание записи в БД (`pending_link`): `member_id`, `code`, `created_at`, `expires_at` (по умолчанию 24 часа), `used = false`.
- **Формирование ссылки**: получение `telegram.bot.username` из конфигурации и сборка `https://t.me/<bot_username>?start=<code>`.
- **Ответ**: JSON с полями `link` и `expires_at`.

#### 6.3. Фронтенд и переход

- Отображение кликабельной ссылки или кнопки **«Перейти в Telegram»**.
- При переходе и нажатии кнопки **«Запустить» (Start)** бот получает команду `/start <code>`.

#### 6.4. Обработка ботом

- `TelegramMessageHandler` извлекает `code` из команды `/start`.
- Поиск записи в `pending_link` по `code` (условия: `used = false` и `expires_at > now()`).
- Если запись найдена:
  - Обновление `telegram_id` у соответствующего `Member`.
  - Пометка кода как использованного (`used = true`) или удаление записи.
  - Ответ в Telegram: «✅ Аккаунт успешно привязан!».
- Если код недействителен — отправка сообщения об ошибке.

### 7. Ежедневные напоминания

- `@Scheduled(cron = "{reminder.cron}")` в `ReminderService`.
- Проверка наличия `TimeEntry` для всех `Member` с привязанным Telegram за текущие сутки.
- Если записей нет — отправка уведомления.

### 8. Конфигурация (application.properties)

```properties
telegram.bot.token=${TELEGRAM_BOT_TOKEN}
telegram.bot.username=${TELEGRAM_BOT_USERNAME}
telegram.polling.interval=5s
telegram.link.cleanup.interval=1h
reminder.cron=0 0 19 * * MON-FRI
reminder.message=Вы ещё не отметили рабочее время сегодня. Отправьте сообщение в формате: `длительность описание` Например: `2:00 разработка API`
```

### 9. Тестирование

- Unit-тесты для парсера (проверка всех форматов времени).
- Интеграционные тесты для REST-клиента (с использованием WireMock или Mockito).
- Тестирование полной цепочки: сообщение боту -> запись в БД.
